import type { NextApiHandler, NextApiRequest } from 'next'
import jwt from 'next-auth/jwt'
import { isMember } from '../../../../src/auth/check-user'
import multer from 'multer'
import {
  apiError,
  apiDataError,
  notAllowedError
} from '../../../../src/services/error-response'
import log from '@bit/kriscarle.maphubs-utils.maphubs-utils.log'
import knex from '../../../../src/connection'
import shortid from 'shortid'
import replaceShortID from '../../../../src/components/Map/Styles/replaceShortID'
import DataLoadUtils from '../../../../src/services/data-load-utils'
import layerViews from '../../../../src/services/layer-views'
import Bluebird from 'bluebird'
import LayerModel from '../../../../src/models/layer'
import GroupModel from '../../../../src/models/group'
import MapModel from '../../../../src/models/map'
import { geobuf } from '@bit/kriscarle.maphubs-utils.maphubs-utils.importers'
import DebugService from '@bit/kriscarle.maphubs-utils.maphubs-utils.debug'

const debug = DebugService('layer-import')

const signingKey = process.env.JWT_SIGNING_PRIVATE_KEY

// Helper method to wait for a middleware to execute before continuing
// And to throw an error when an error happens in a middleware
function runMiddleware(req, res, fn) {
  return new Promise((resolve, reject) => {
    fn(req, res, (result) => {
      if (result instanceof Error) {
        return reject(result)
      }

      return resolve(result)
    })
  })
}

const handler: NextApiHandler = async (req, res) => {
  const user = (await jwt.getToken({
    req,
    signingKey
  })) as { sub: string }

  if (
    process.env.NEXT_PUBLIC_REQUIRE_LOGIN === 'true' &&
    (!user?.sub || !isMember(user))
  ) {
    return res.status(401).json({
      error: 'Login required'
    })
  }
  const user_id = Number.parseInt(user.sub)

  // Run the middleware
  await runMiddleware(
    req,
    res,
    multer({
      dest: process.env.TEMP_FILE_PATH + '/uploads/'
    }).single('file')
  )

  try {
    const group_id = req.query.group_id as string
    debug.log('adding to group: ' + group_id)

    // multer attaches the file to the request
    const reqExtended = req as NextApiRequest & {
      file: {
        originalname: string
        mimetype: string
        path: string
      }
    }
    const file = reqExtended.file

    if (!file) {
      res.status(500).json({
        error: 'No file uploaded (possible issue with multer middleware)'
      })
    }

    if (group_id) {
      if (await GroupModel.allowedToModify(group_id, user_id)) {
        debug.log('Filename: ' + file.originalname)
        debug.log('Mimetype: ' + file.mimetype)

        if (file.originalname.endsWith('.maphubs')) {
          const importerResult = await geobuf(file.path, -1)
          const maphubsFile = importerResult.maphubs
          delete importerResult.maphubs
          log.info(
            `MapHubs File v${maphubsFile.version} - Generated by ${maphubsFile.host}(${maphubsFile.systemVersion}) at ${maphubsFile.exportTime} `
          )

          if (maphubsFile.version === 3 && maphubsFile.type === 'map') {
            // Map import support, added in version 3
            const mapHubsMap = maphubsFile.map
            console.log(mapHubsMap)
            // First extract and create the layers
            // using the old short-ids, pull out the layers and their features
            const layerMap = {}
            for (const layer of maphubsFile.layers) {
              layerMap[layer.shortid] = layer
              layerMap[layer.shortid].geojson = {
                type: 'FeatureCollection',
                features: []
              }
            }
            for (const feature of importerResult.features) {
              const shortid = feature.layer_short_id

              if (shortid && layerMap[shortid]) {
                layerMap[shortid].geojson.features.push(feature)
              } else {
                console.error(`Failed to find layer with id: ${shortid}`)
              }
            }
            // now create each layer
            knex.transaction(async (trx) => {
              const keys = Object.keys(layerMap)
              const layersList = []
              await Bluebird.mapSeries(keys, async (old_short_id) => {
                const maphubsLayer = layerMap[old_short_id]
                const presets = maphubsLayer.presets
                // replace shortid
                const newId = shortid.generate()
                maphubsLayer.shortid = newId
                maphubsLayer.style = replaceShortID(
                  old_short_id,
                  newId,
                  maphubsLayer.style
                )
                // also update the map style
                mapHubsMap.style = replaceShortID(
                  old_short_id,
                  newId,
                  mapHubsMap.style
                )
                // create the layer
                const layerGeoJSON = maphubsLayer.geojson
                // layers imported from Maps may have these
                delete maphubsLayer.default_style
                delete maphubsLayer.default_labels
                delete maphubsLayer.default_legend_html
                delete maphubsLayer.default_settings
                delete maphubsLayer.geojson
                delete maphubsLayer.map_id
                delete maphubsLayer.position
                delete maphubsLayer.short_id // some FR layers have this

                // imports from FR may not have all metadata
                if (!maphubsLayer.description)
                  maphubsLayer.description = maphubsLayer.title
                if (!maphubsLayer.license) maphubsLayer.license = 'none'
                if (!maphubsLayer.status) maphubsLayer.status = 'published'
                maphubsLayer.published = true
                // assign this user
                maphubsLayer.created_by_user_id = user_id
                maphubsLayer.creation_time = trx.raw('now()')
                const layer_id = await LayerModel.importLayer(
                  maphubsLayer,
                  group_id,
                  user_id,
                  trx
                )
                maphubsLayer.layer_id = layer_id
                console.log(`created layer ${layer_id}`)

                // insert layer data, if provided
                if (layerGeoJSON.features.length > 0) {
                  await DataLoadUtils.storeTempGeoJSON(
                    layerGeoJSON,
                    file.path,
                    layer_id,
                    maphubsLayer.shortid,
                    false,
                    false,
                    trx
                  )
                  await DataLoadUtils.loadTempData(layer_id, trx)
                  await layerViews.createLayerViews(layer_id, presets, trx)
                  debug.log('data load transaction complete')
                }

                layersList.push(maphubsLayer)
                return LayerModel.setComplete(layer_id, trx)
              })
              // now create the map
              const map_id = await MapModel.createGroupMap(
                layersList,
                mapHubsMap.style,
                mapHubsMap.basemap,
                mapHubsMap.position,
                mapHubsMap.title,
                mapHubsMap.settings,
                user_id,
                group_id,
                trx
              )
              return res.status(200).json({
                success: true,
                type: 'map',
                map_id
              })
            })
          } else if (maphubsFile.version <= 2 || maphubsFile.type === 'layer') {
            // Version 2 only supports layers
            const maphubsLayer = maphubsFile.layer
            const presets = maphubsLayer.presets
            // replace shortid
            const newId = shortid.generate()
            const oldId = maphubsLayer.shortid
            maphubsLayer.shortid = newId
            maphubsLayer.style = replaceShortID(
              oldId,
              newId,
              maphubsLayer.style
            )
            return knex.transaction(async (trx) => {
              // create the layer
              const layer_id = await LayerModel.importLayer(
                maphubsLayer,
                group_id,
                user_id,
                trx
              )

              // insert layer data, if provided
              if (importerResult.features.length > 0) {
                await DataLoadUtils.storeTempGeoJSON(
                  importerResult,
                  file.path,
                  layer_id,
                  maphubsLayer.shortid,
                  false,
                  false,
                  trx
                )
                await DataLoadUtils.loadTempData(layer_id, trx)
                await layerViews.createLayerViews(layer_id, presets, trx)
                debug.log('data load transaction complete')
              }

              await LayerModel.setComplete(layer_id, trx)
              return res.status(200).json({
                success: true,
                type: 'layer',
                layer_id
              })
            })
          } else {
            throw new Error('Unsupported MapHubs file format')
          }
        } else {
          // only .maphubs files supported
          throw new Error('MapHubs File Not Found')
        }
      } else {
        return notAllowedError(res, 'layer')
      }
    } else {
      apiDataError(res)
    }
  } catch (err) {
    apiError(res, 500)(err)
  }
}
export default handler

export const config = {
  api: {
    bodyParser: {
      sizeLimit: '250mb'
    }
  }
}
